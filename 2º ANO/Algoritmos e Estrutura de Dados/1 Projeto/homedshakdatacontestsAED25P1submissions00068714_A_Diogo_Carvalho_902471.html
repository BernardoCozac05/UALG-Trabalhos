<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>Report of submission 00068714_A_Diogo_Carvalho_90247</title>
<link
rel	="stylesheet"
href	="../../styles/base.css"
type	="text/css">
</head>
<body>
<h2>Report #1</h2>

<table>
<tr>
<th>Submission</th>
<td>
<a href="?inspect+data/contests/AED25P1/submissions/00068714_A_Diogo_Carvalho_90247">00068714_A_Diogo_Carvalho_90247</a>
</td>
</tr>
<tr>
<th>File</th>
<td>
<a href="?inspect+data/contests/AED25P1/submissions/00068714_A_Diogo_Carvalho_90247/Scene.java">Scene.java</a>
<a href="data/contests/AED25P1/submissions/00068714_A_Diogo_Carvalho_90247/Scene.java">[Download]</a>
</td>

<tr><th>Received</td>	<td>Mon Sep 22 12:32:48 +0100 2025</td></tr>
<tr><th>Analyzed</td>	<td>Mon Sep 22 12:32:48 +0100 2025 (0:00:00)</td></tr><tr>
<th>Team</th>
<td>
<a href="?inspect+data/contests/AED25P1/groups/students/Diogo_Carvalho_90247">
Diogo_Carvalho_90247
</a> Login: <code>Diogo_Carvalho_90247</code> Group: students [students]
</td><tr>
<th>Language</th>
<td>
<a href="?inspect+data/contests/AED25P1/languages/Java">
Java
</a>
</td><tr>
<th>Problem</th>
<td>
<a href="?inspect+data/contests/AED25P1/problems/A">
A: Option
</a>
</td><tr>
<th>Compilation</th>
<td>src/Option.java:5: error: class Scene is public, should be declared in a file named Scene.java
public class Scene {
       ^
src/OptionTest.java:7: error: cannot access Option
    private static final Option o1 = new Option(0,"Go left.");
                         ^
  bad source file: src/Option.java
    file does not contain class Option
    Please remove or make sure it appears in the correct subdirectory of the sourcepath.
src/OptionTest.java:7: error: cannot access Option
    private static final Option o1 = new Option(0,"Go left.");
                                         ^
  bad source file: src/Option.java
    file does not contain class Option
    Please remove or make sure it appears in the correct subdirectory of the sourcepath.
3 errors</td>
</tr>
</table><table>
<tr>	<th>CPU	  </th><td>0 (0) sec</td>	</tr>
<tr>	<th>Memory	  </th><td>0 kbytes</td>			</tr>
<tr>	<th>Classification</th><td>Compile Time Error</td>		</tr>
<tr>	<th>Mark</th>	  <td>0</td>		</tr>
<tr>
<th valign="top">Observations</th>
<td><pre></pre></td>
</tr>
<tr>
<th valign="top">Feedback</th>
<td><pre></pre></td>
</tr>

<tr>
<th>Code</th>
<td></td>
</table>
<pre>
import java.io.BufferedReader;
import java.io.IOException;
import java.util.ArrayList;

public class Scene {
    /** Enumerado dos tipos de cena válidos */
    public enum Type { NORMAL, WON, FAILED }

    private final int id;
    private final String description;
    private final Type type;
    private final ArrayList&lt;Option&gt; options;

    /**
     * Construtor que cria uma cena com identificador, descrição e tipo especificados.
     * Lança IllegalArgumentException se algum argumento for inválido (id negativo, descrição nula ou vazia, tipo nulo).
     */
    public Scene(int id, String description, Type type) {
        if (id &lt; 0 || description == null || description.isEmpty() || type == null) {
            throw new IllegalArgumentException("Argumentos inválidos para Scene");
        }
        this.id = id;
        this.description = description;
        this.type = type;
        this.options = new ArrayList&lt;&gt;();
    }

    /**
     * Adiciona uma nova opção à cena, se não existir já uma opção com o mesmo identificador.
     * @param o opção a ser adicionada
     * @return true se a opção foi adicionada com sucesso; false se já existe opção com o mesmo id (não adicionada)
     * @throws IllegalArgumentException se a opção fornecida for nula
     */
    public boolean addOption(Option o) {
        if (o == null) {
            throw new IllegalArgumentException("Opção nula");
        }
        for (Option existing : options) {
            if (existing.getId() == o.getId()) {
                // Já existe uma opção com este id
                return false;
            }
        }
        options.add(o);
        return true;
    }

    /** Retorna o identificador desta cena. */
    public int getId() {
        return id;
    }

    /** Retorna o tipo (enumerado) desta cena. */
    public Type getType() {
        return type;
    }

    /** Retorna a descrição textual desta cena. */
    public String getDescription() {
        return description;
    }

    /** Retorna um iterável com todas as opções desta cena (na ordem de adição). */
    public Iterable&lt;Option&gt; getOptions() {
        return options;
    }

    /**
     * Retorna uma representação textual completa da cena.
     * Formato:
     * [&lt;id&gt;]
     * &lt;descrição&gt;
     * &lt;opção 1&gt;
     * ...
     * &lt;opção n&gt;
     * 
     * Se a cena for do tipo WON ou FAILED, as opções são substituídas por &amp;lt;WON&amp;gt; ou &amp;lt;FAILED&amp;gt;.
     */
    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append("[").append(id).append("]\n");
        sb.append(description).append("\n");
        if (type == Type.WON) {
            sb.append("&lt;WON&gt;");
        } else if (type == Type.FAILED) {
            sb.append("&lt;FAILED&gt;");
        } else {
            // Cena NORMAL: listar opções
            for (int i = 0; i &lt; options.size(); i++) {
                Option opt = options.get(i);
                sb.append(opt.toString());
                // Adiciona newline após cada opção, exceto talvez após a última (remoção abaixo)
                sb.append("\n");
            }
            // Remover newline extra no final (se existirem opções)
            if (!options.isEmpty()) {
                sb.deleteCharAt(sb.length() - 1);
            } else {
                // Se não houver opções (caso raro), remover newline após descrição
                sb.deleteCharAt(sb.length() - 1);
            }
        }
        return sb.toString();
    }

    /**
     * Lê do BufferedReader fornecido para criar e retornar um objeto Scene.
     * Espera que o leitor esteja posicionado no início de uma cena, seguindo o formato especificado.
     * O BufferedReader não é fechado por este método.
     * @param br BufferedReader aberto de onde ler a cena
     * @return Scene criada a partir do texto lido
     * @throws IOException se ocorrer um erro de leitura do BufferedReader ou se o formato esperado não for encontrado
     * @throws NumberFormatException se não for possível ler/interpretar um número inteiro esperado (por exemplo, o id da cena ou id de opção inválido)
     */
    public static Scene parseScene(BufferedReader br) throws IOException, NumberFormatException {
        // Ler primeira linha com [id]
        String line = br.readLine();
        if (line == null) {
            throw new IOException("ID da cena não encontrado");
        }
        String idLine = line.trim();
        if (!idLine.startsWith("[") || !idLine.endsWith("]") || idLine.length() &lt; 2) {
            // Formato inválido para o identificador da cena
            throw new NumberFormatException("Formato de identificador inválido");
        }
        String idNumberStr = idLine.substring(1, idLine.length() - 1).trim();
        int sceneId;
        try {
            sceneId = Integer.parseInt(idNumberStr);
        } catch (NumberFormatException e) {
            // Reencaminhar exceção de número inválido
            throw e;
        }

        // Ler marcador de início da descrição "&lt;&lt;&lt;"
        String marker = br.readLine();
        if (marker == null) {
            throw new IOException("Início de descrição '&lt;&lt;&lt;' não encontrado");
        }
        if (!marker.trim().equals("&lt;&lt;&lt;")) {
            throw new IOException("Formato inválido: esperado '&lt;&lt;&lt;'");
        }

        // Ler linhas de descrição até encontrar o terminador de descrição (&gt;&gt;&gt;...).
        StringBuilder descBuilder = new StringBuilder();
        Scene.Type sceneType = null;
        while (true) {
            line = br.readLine();
            if (line == null) {
                throw new IOException("Fim da descrição não encontrado");
            }
            String trimmed = line.trim();
            if (trimmed.startsWith("&gt;&gt;&gt;")) {
                // Encontrou terminador de descrição
                if (trimmed.equals("&gt;&gt;&gt;")) {
                    sceneType = Type.NORMAL;
                } else if (trimmed.equals("&gt;&gt;&gt;WON")) {
                    sceneType = Type.WON;
                } else if (trimmed.equals("&gt;&gt;&gt;FAILED")) {
                    sceneType = Type.FAILED;
                } else {
                    // Terminador desconhecido
                    throw new IOException("Terminador de descrição inválido");
                }
                break;  // sair do loop de leitura da descrição
            } else {
                // Linha de descrição normal (preservar exatamente como está)
                descBuilder.append(line).append("\n");
            }
        }
        // Remover o último newline extra da descrição (se existe)
        if (descBuilder.length() &gt; 0 &amp;&amp; descBuilder.charAt(descBuilder.length() - 1) == '\n') {
            descBuilder.deleteCharAt(descBuilder.length() - 1);
        }
        String description = descBuilder.toString();

        // Criar a cena de acordo com o tipo determinado
        if (sceneType == null) {
            // Por segurança, mas sceneType deve ter sido definido no loop
            throw new IOException("Tipo de cena não determinado");
        }
        Scene scene = new Scene(sceneId, description, sceneType);

        // Se a cena for NORMAL, ler e adicionar as opções entre os marcadores ***.
        if (sceneType == Type.NORMAL) {
            // Ler linha "***" inicial das opções
            String optsStart = br.readLine();
            if (optsStart == null) {
                throw new IOException("Início das opções '***' não encontrado");
            }
            if (!optsStart.trim().equals("***")) {
                throw new IOException("Formato inválido: esperado '***' antes das opções");
            }
            // Ler cada opção até encontrar o final das opções '***'
            while (true) {
                line = br.readLine();
                if (line == null) {
                    throw new IOException("Fim das opções '***' não encontrado");
                }
                String optLine = line.trim();
                if (optLine.equals("***")) {
                    // Encontrou marcador de fim das opções
                    break;
                }
                // Interpretar opção
                Option option = Option.parseOption(line);
                // Adicionar opção à cena (respeita a restrição de id único)
                scene.addOption(option);
            }
        }
        return scene;
    }
}

</pre>

</body>